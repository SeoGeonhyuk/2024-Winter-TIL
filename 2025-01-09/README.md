# NodeJS의 논블로킹 방식
- nodeJS는 논블로킹(비동기) IO를 지원하는 싱글 스레드 기반의 런타임.
- 이번 시간에는 실제로 nodeJS가 논블로킹 IO를 어떤 형태로 지원하고 있는지 알아보자.
- 논블로킹 I/O를 이해하기 전에, 소켓과 fd에 대한 개념을 먼저 알아야 한다.
    - 소켓은 기본적으로 fd(file descriptor)를 통해 접근할 수 있다. fd는 소켓 자체가 아니라, 소켓 메모리를 참조하기 위한 핸들이다. 따라서 소켓을 파일 그 자체라고 말하는 것은 다소 부정확하다.
        - fd란 file descriptor의 약자로, 운영체제에서 시스템 리소스에 접근하기 위한 추상화된 인덱스값을 나타낸다.
        - 이러한 fd는 fd 테이블을 통해 관리되며, 각 프로세스는 고유의 fd 테이블을 가지고 있다.
        - 이로 인해 파일, 소켓, 파이프, 익명 메모리, 디바이스 파일 등 다양한 리소스를 fd를 통해 공통된 방식으로 접근할 수 있다.
    - 또한 특정 포트에서 외부의 연결을 수신하는 소켓과 연결이 들어와 외부 사용자와 데이터를 주고받는 소켓은 다른 소켓이다.
    - 각 소켓은 기본적으로 수신 버퍼와 송신 버퍼를 가지고 있다. 그리고 수신 버퍼와 송신 버퍼는 블로킹되는 상황이 발생할 수 있다.
        - 예를 들어 소켓에서 send() 함수를 통해 반대편 사용자에게 데이터를 보내려고 하는데 보낼 데이터가 없다면? 스레드는 보낼 데이터가 생길 때까지 해당 함수에서 블로킹된다.
        - 소켓에서 recv() 함수를 통해 반대편 사용자가 전송한 데이터를 받으려고 하는데 받을 데이터가 없다면? 스레드는 받을 데이터가 생길 때까지 해당 함수에서 블로킹된다.
- 이러한 소켓의 블로킹 상황을 막기 위해 이전부터 비동기 방식의 소켓 접근 방식을 지원했다. 이번에는 epoll 방식에 대해서만 설명한다.
    - epoll 같은 경우에는 위와 같은 예시를 가진 소켓들을 걸러내고 블로킹 상황이 발생하지 않을 소켓들만 따로 큐에 담아둬서 해당 소켓들에 대해서 요청을 처리하는 방식이다.
    - epoll 방식은 엣지 트리거 방식으로 운용되는데, 이러한 엣지 트리거 방식을 사용하기 위해서는 큐에 담겨있는 소켓 하나하나의 요청을 처리할 때 블로킹 상황이 발생할때까지 처리해야 한다.(예를 들어 송신 버퍼의 최대 크기가 600인데, 보내야 할 데이터의 크기가 1000이라면, 600 400 나눠서 보낼 수 있겠지만(TCP) 600만 보내고 끝난다면, 이미 활성화된 엣지 트리거는 이후 400을 인식하지 못하고 계속 남아있게 만든다. 그러므로 600, 400을 다 보내서 엣지 트리거를 강제로 내려야 하는 것이다.)
- nodeJS에서도 이러한 epoll 방식을 사용해 네트워킹 논블로킹 IO를 구현하였다. 소켓 뿐만 아니라 파일에 접근하는 비동기 방식도 이러한 방향으로 구현되어 있다. 그리고 메인 스레드의 블로킹을 막기 위해서 epoll을 활용한 논블로킹 IO는 메인 스레드가 아니라 여러 개의 워커 스레드(libuv)를 활용한다.

# 참고 자료

[[번역] NodeJS의 비동기 IO](https://velog.io/@surim014/async-io-in-nodejs)

[소켓(Socket) 프로그래밍(Socket 이해하기)](https://russell-seo.tistory.com/18)